{
  "title": "chapter 3",
  "cells": [
    {
      "type": "text",
      "data": "<ul><li><span style=\"line-height: 1.4;\">nameing space</span><br></li></ul><ol><ol><li>using std::string;</li><li>using namespace std; // will make following namespace std</li><li>Hearders should not include using statement because it might be included by other files while wo do not want other files to use osme namespace as default</li></ol></ol><span style=\"line-height: 1.4;\"><ul><li><span style=\"line-height: 1.4;\">library string type</span><br></li></ul></span><ol><ol><li>to use this type: &nbsp;#include &lt;string&gt; &nbsp; &nbsp;using std::string</li><li>defining and initing strings:</li><ol><li>string s; // default dmpty string</li><li>string s1 = s; // s1 is a copy of s same as string s1(s)</li><li>string s2(“aaa”); // direct initialization with s2 == aaa same as string s2 = “aaa”;</li><li>string s3(3, ‘a’); // s3 == “aaa”&nbsp;</li></ol><li>reading and writing strings</li><ol><li>string word; &nbsp; while(cin &gt;&gt; word) // reading strs into word until EOF</li><li>string line; &nbsp; &nbsp; while(getline(cin, line)) // read each line until EOF</li><li>adding literals and strings, make sure that literals not added to literals directly</li></ol><li>hanlding chars</li><ol><li>enhencecd for loop: &nbsp;string s = “aaaa”; &nbsp;for(char temp : s) {}</li><li>** cctype functions, identifying and handlong chars in a string</li></ol></ol></ol><span style=\"line-height: 1.4;\"><ul><li><span style=\"line-height: 1.4;\">library vector type</span><br></li></ul></span><ol><ol><li>vector is also a library thing so to use it we need to include &lt;vector&gt; and also name it</li><li>vector is not a type, it is a template and combined with an element type, it could be a container type</li><li>vector definition and initialization</li><ol><li>default is an empty vector like: &nbsp; vector&lt;int&gt; v; // empty int vector</li><li>def with an existing vector like: &nbsp; vector&lt;int&gt; v1(v); or vector&lt;int&gt; v1 = v;</li><li>def with curly braces like: vector&lt;int&gt; v2 {1, 1, 1}; or vector&lt;int&gt; v2 = {1, 1, 1};</li><li>def with args list like: vector&lt;int&gt; v3(10, 0); // first is number end second is initial value, if the element type has some default value then the second one is optional</li></ol><li>adding element to the vector: push_back some element&nbsp;</li><ol><li>while accessing the element, adding would casue some error</li><li>make sure that index is always in range</li></ol><li>other operations</li><ol><li>vector&lt;int&gt;::size_type //the element type is necessary</li><li>size() empty() push_back(ele_name) []</li><li>v1 = v2; v1 = {…} // assignment with vector or bundle of elements</li><li>equal and not equal; comparison</li></ol></ol></ol><span style=\"line-height: 1.4;\"><ul><li><span style=\"line-height: 1.4;\">iterators</span><br></li></ul></span><ol><ol><li>using iterator</li><ol><li>begin() &nbsp;end() and * which means dereference and return the reference of the pointed object</li><li>arithmatic operation of iterator: ++ — += -= would move the iterator forward or backward</li></ol></ol></ol>"
    },
    {
      "type": "code",
      "language": "c_cpp",
      "data": "//make use of iterator to do binary searching\nauto beg = text.begin(), end = text.end();\nauto mid = beg + (end - beg) / 2; // why? to avoid overflow\nwhile(mid != end && *mid != target) {\n  if(*mid > sought)\n    beg = mid + 1;\n  else \n    end = mid;\n  mid = beg + (end - beg) / 2;\n}\nif(mid == end) \n  return -1;\nreturn (int)(mid - text.begin()); "
    },
    {
      "type": "text",
      "data": "<ul><li>arrays — array is a container of fixed size and might have better performance for this</li><ul><li>define a array with a constexpr</li><ul><li>int i = 10; const int ci = 10; int a[i]; // error coz i is not const int a[ci]; //okay because its const</li></ul><li>initialization of an array — const int ci = 3;</li><ul><li>int a[ci] = {1, 2, 3};</li><li>int a[ci];</li><li>int a[] = {1, 2, 3}; // if list on the other side, the size could be omitted</li><li>string a[3] = {“aaa”, “bbb”}; // if num of element is less than size, add default element</li><li>int a[1] = {“aaa”}; //error different types</li></ul><li>char array — if we want to use c string functions like strlen, include &lt;cstring&gt;</li><ul><li>char a[] = {‘a’, ‘b’, ‘c’}; // then a is a char array without null in the end</li><li>char a[] = “aaa”; // the strlen of a is still 3 but size of the array is 4</li><li>char a[3] = “aaa”; // not enough space &nbsp;char a[4] = “aaa”; this is not okay — string is too long for char array</li></ul><li>there is no copy assignment in array so given int a[] = {1, 2, 3};</li><ul><li>int b[] = a; // error no copy init</li><li>int b[3]; b = a; // error no assignment</li></ul><li>complicated array declaration</li><ul><li>int *ptrs[10]; //okay array of pointers</li><li>int &amp;refs[10] = arr; //error there are no array of refs</li><li>int (*ptr)[10]; //here it means that ptr is a pointer to a int array</li><li>int (&amp;ref)[10] = arr; // here ref is a reference to a ten int array</li><li>int *(&amp;ref)[10] = ptrs; // here ref is a ref of a ten ptr array</li></ul><li>access element of an array — size_t&nbsp;</li><ul><li>in c++, programmers should check if index is in correct range</li></ul></ul><li>poitners and array</li><ul><li>given some array arr: then arr == &amp;arr[0];</li><li>auto arr0(arr) here arr0 is an int pointer;</li><li>after getting the pointer related to array</li><ul><li>accesing element using pointer (the index could be neg but need to make sure that the pos is in range)</li><li>pointer arithmetic</li><li>begin(arr) and end(arr) are both pointer of the element type</li></ul></ul><li>C style character string</li><ul><li>include &lt;cstring&gt; : strlen strcmp strcat(p1, p2); // append p2 to p1 and return p1 strcpy(p1, p2); // copy p2 to p1 and return p1</li><li>init vector using an array(arr) &nbsp;vector&lt;int&gt; v_arr(begin(arr), end(arr));</li></ul><li>multiple dimensions array</li><ul><li>only size of first dimension is optional all others have to be specified like int a[][2] = {…};&nbsp;</li><li>if there are enought elements, then we could omit the inner curly braces;</li><li>or the behavior differs(without curly braces, all elements would be filled one by one) with curly braces, it would jump to another inner array when reaching the end of an inner brace</li></ul></ul>"
    },
    {
      "type": "text",
      "data": "<div><br></div><div><br></div>"
    }
  ]
}