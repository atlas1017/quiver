{
  "title": "LeetCode 基本思路",
  "cells": [
    {
      "type": "text",
      "data": "<ol><li style=\"font-size: 16px;\">two sum — simple hashing</li><li style=\"font-size: 16px;\">add two numbers — easy pointer</li><li style=\"font-size: 16px;\">longest substring without repeating characters — pointer， runner 在前面走 每次把（value， index）放进HashMap里 如果没找到重复的 update最大的。等到找到重复的 更新HashMap 剔除之前那个之前的（从一个start 到 拿到的index 包括在内）然后放进去当前的。</li><li style=\"font-size: 16px;\">median of two sorted array — 一个式子包含两种情况 + 找到从1开始的第k个数字 + 避免越界 + 两个加起来等于k</li><li style=\"font-size: 16px;\">longest palindrome substring — easy DP 注意的是从长度作为outer loop</li><li style=\"font-size: 16px;\">string into integer — handle +/- and extreme case and illegal case</li><li style=\"font-size: 16px;\">regular expression matching — 首先parse出来标记哪些是*的数字 有点tricky注意处理位置 if(arr2[j - 1] is with *) dp dp[i][j] = dp[i][j - 1] || (arr2[j - 1] == arr1[i - 1] &amp;&amp; (dp[i - 1][j - 1] || dp[i - 1][j]) )</li><li style=\"font-size: 16px;\">container with most water — 2 pointers and greedy</li><li style=\"font-size: 16px;\">3sum — sort and then 2 pointers; 3sum closest — 2 pointer走的方向一致 但是不add 只keep最小的；4sum — 两层for loop + 2 pointers</li><li style=\"font-size: 16px;\">implement strStr() — brute force or DP string matching’s DP means ending matching there</li><li style=\"font-size: 16px;\">divide integers — 动态变化 + 用long替代int</li><li style=\"font-size: 16px;\">substring with concatenation of all words — hashmap + brute force</li><li style=\"font-size: 16px;\">longest parentheses — stack 举例子处理边界条件</li><li style=\"font-size: 16px;\">search insert position — binary search 之后left就是insert position；</li><li style=\"font-size: 16px;\">sudoku solver — 是找一个正确的答案 如果找到了不reset the grid； 找不到的话 reset to .</li><li style=\"font-size: 16px;\">combination sum — target == 0 是结束条件；用完之后可以继续用 还是i； 去掉重复的条件（相同的只需要考虑一次 因为所有的数字都可以重复利用）； combination sum 2 — 只改动了一个地方 从 i 到 i + 1;&nbsp;</li><li style=\"font-size: 16px;\">** 重复的条件去掉 只对于entry 后面并不会跳过相同的元素 因为多个同时存在的时候 还是需要接受的&nbsp;</li><li style=\"font-size: 16px;\">first missing number — 我们想要把所有的数字归位 — 如果不能用其它的space 能不能修改</li><li style=\"font-size: 16px;\">trapping rain water — 找到最大的一组 — 全局出发</li><li style=\"font-size: 16px;\">whildcard matching — 第一个办法 DP； 第二个约等于greedy&nbsp;</li><li style=\"font-size: 16px;\">jump game — 只要update当前能到的最远距离就好；jump game II — 维护每一段的开始的pos 和 结束的pos， 第一个表示至少k步才能到 最后一个表示k步的最远距离</li><li style=\"font-size: 16px;\">permutations II — 如何避免重复 entry的时候如果重复 跳过；</li><li style=\"font-size: 16px;\">group anagrams — hash and sort</li><li style=\"font-size: 16px;\">N-Queens and N-Queens II — backtracking 保存结果最后 所以无论如何都可以reset回来</li><li style=\"font-size: 16px;\">insert intervals and merge intervals — find ovelap and then reinsert it, and do this insertion for each interval, which we would do the merging</li><li style=\"font-size: 16px;\">sqrt(x) — binary search — mean of 2 &nbsp;— s + (t - s) / 2 &nbsp;— avoid over flow</li><li style=\"font-size: 16px;\">edit distance — typical DP</li><li style=\"font-size: 16px;\">sort color — counting sort</li><li style=\"font-size: 16px;\">decode ways — DP 放在后面处理</li><li style=\"font-size: 16px;\">interleaving string — 3D DP</li><li style=\"font-size: 16px;\">** recover binary search tree — pre first and second;&nbsp;</li><li style=\"font-size: 16px;\">** distinct subsequences s = &nbsp;“rabbbit\" t = “rabbit” 3; &nbsp;dp[i][j] = dp[i - 1][j]; dp[i][j] += i-1 == j-1? dp[i - 1][j - 1] : 0;</li><li style=\"font-size: 16px;\">populating next right pointer to each node — prevHead, prevCur, prev, cur;</li><li style=\"font-size: 16px;\">** buy and sell stock — 1. 维护最小的 不update的话 就看看要不要update max； 2. take all profits &nbsp;3.divide and then solve; 4. 隔一天 一亩三分地 5. 见leetcode<span style=\"line-height: 1.4;\">&nbsp;</span></li><li style=\"font-size: 16px;\"><span style=\"line-height: 1.4;\">word ladder I&nbsp;</span>—<span style=\"line-height: 1.4;\">&nbsp;BFS &nbsp;word ladder II&nbsp;</span>—<span style=\"line-height: 1.4;\">&nbsp;two direction BFS</span></li><li style=\"font-size: 16px;\"><span style=\"line-height: 1.4;\">longest consecutive sequence&nbsp;</span>—<span style=\"line-height: 1.4;\">&nbsp;sort then search from center (keep visited)&nbsp;</span>—<span style=\"line-height: 1.4;\">&nbsp;用HashMap维护两边很巧妙</span></li><li style=\"font-size: 16px;\"><span style=\"line-height: 1.4;\">** surrounded region&nbsp;</span>—<span style=\"line-height: 1.4;\">&nbsp;去掉中间连不到四条边的 DFS and mark&nbsp;</span>—<span style=\"line-height: 1.4;\">&nbsp;可以mark自己</span></li><li style=\"font-size: 16px;\">palindrome partitioning — 找下一个palindrome DFS backtracking; palindrome partitioning II — 1.construct all palindrome pair using DP 2. from worse case and update that from matrix. (parts) 3. minus one to cuts</li><li style=\"font-size: 16px;\">clone graph — recursion — if have visited before then add it to list or call recursively;</li><li style=\"font-size: 16px;\">gas station — farthest that we could go — skip all those and start from next; — handle cycle</li><li style=\"font-size: 16px;\">candy — greedy 往上走的时候 +1 不然从一开始 如果往下走 走到底之后回来update</li><li style=\"font-size: 16px;\">single number — ^; single number II — count from bit and % to 3;</li><li><span style=\"font-size: 17px;\">word break — basic DP; word break II — DFS with heuristic;</span><br style=\"font-size: 16px;\"></li></ol>"
    }
  ]
}