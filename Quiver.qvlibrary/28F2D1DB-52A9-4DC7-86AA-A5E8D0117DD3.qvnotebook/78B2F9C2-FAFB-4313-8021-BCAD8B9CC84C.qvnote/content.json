{
  "title": "Google 面试准备",
  "cells": [
    {
      "type": "text",
      "data": "<div style=\"font-size: 14px;\">准备做的事情：<br></div><div><div style=\"font-size: 14px;\"><ol><li>整理LeetCode &nbsp;(周六+ 周天上午)<br></li><li>整理Google的面试题（自己mock interview)</li><li>找人mock interview &nbsp;Ricky &amp; 傅赓</li><li>CTCI 还是要看书！</li></ol><div><br></div></div><div style=\"font-size: 14px;\">读Google preparation guide</div><div><ol><li style=\"font-size: 14px;\">准备简历上面的东西<br></li><li style=\"font-size: 14px;\">刷题的步骤练习 — 先搞清楚问题 talk — 思考普通的解法 — 考虑tradeoff &nbsp;— 改进解法 锻炼解释 — 在Google doc里面写 写出来之后分析bigO</li><li style=\"font-size: 14px;\">需要特别注意的问题</li><ol><li style=\"font-size: 14px;\">distill large data sets to single values</li><li style=\"font-size: 14px;\">transform one data set to another</li><li style=\"font-size: 14px;\">mergeSort and&nbsp;quickSort (quickSelect) — 什么时候这两个是less efficient的&nbsp;</li><li style=\"font-size: 14px;\"><span style=\"line-height: 1.4;\">Wiggle sort&nbsp;</span></li><li style=\"font-size: 14px;\">NP complete- problems&nbsp;traveling salesman and the knapsack problem</li><li style=\"font-size: 14px;\">implement hashMap &nbsp;hashMap 的操作bigO分析</li><li style=\"font-size: 14px;\">Trie Tree / red black tree</li><li style=\"font-size: 14px;\">max heap and min heap (no need to implement but know when to use and what is the bigO for each operation)</li><li><span style=\"font-size: 14px;\">graph DFS and BFS（bigO） — 图的表示方法 objects and pointers, matrix, and adjacency list（优劣）— </span><span style=\"background-color: rgb(254, 250, 0);\"><span style=\"font-size: 14px;\">最短路径&nbsp;</span><span style=\"font-size: 14px; line-height: 19px;\">—</span><span style=\"font-size: 14px;\">&nbsp;总是找连接set里 和 set外的最短路径&nbsp;</span><span style=\"font-size: 14px; line-height: 19px;\">—</span><span style=\"font-size: 14px;\">&nbsp;直到所有的点都被放进去</span></span></li><li style=\"font-size: 14px;\"><span style=\"background-color: rgb(254, 250, 0);\">processes, threads, concurrency issues, locks, mutexes, semaphores, monitors and how they all work.&nbsp;</span></li><li style=\"font-size: 14px;\"><span style=\"background-color: rgb(254, 250, 0);\">Understand deadlock, livelock and how to avoid them. Know what resources a process needs and a thread needs. Understand how context switching works, how it's initiated by the operating system and underlying hardware.&nbsp;</span></li><li style=\"font-size: 14px;\"><span style=\"background-color: rgb(254, 250, 0);\">Know a little about scheduling. The world is rapidly moving towards multi-core, so know the fundamentals of \"modern\" concurrency constructs&nbsp;</span></li></ol><li style=\"font-size: 14px;\"><span style=\"background-color: rgb(254, 250, 0);\">heap 操作的时间复杂度和空间复杂度</span></li><li style=\"font-size: 14px;\"><img src=\"quiver-image-url/166FC90C-0CB3-497D-8179-E6BC1DBCC864.png\"><br></li><li><font color=\"#555555\" face=\"Tahoma, Microsoft Yahei, STXihei, Simsun\"><a href=\"http://www.cnblogs.com/buptLizer/archive/2012/04/08/2437416.html\" style=\"font-size: 14px;\">http://www.cnblogs.com/buptLizer/archive/2012/04/08/2437416.html</a><span style=\"font-size: 14px;\">&nbsp;</span><span style=\"font-size: 14px; line-height: 19px;\">—</span><span style=\"font-size: 14px;\">&nbsp;关于 reservoir sampling</span></font></li><li style=\"font-size: 14px;\">第二轮：<font class=\"jammer\"></font><br>Nth fibonacci number<font class=\"jammer\"></font><br>implement queue using stack<font class=\"jammer\"></font><br>implement a stack and able to query minimum value in O(1) time<font class=\"jammer\"></font><br>given one BST, find the Kth minimum value — one query or many queries<br></li><li style=\"font-size: 14px;\">BST 和 Hash Table 的适用场合以及性能比较</li><li><font color=\"#444444\"><span style=\"font-size: 14px;\">题目一 字典里面没有重复的character 要求两个乘积最大 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style=\"background-color: rgb(254, 250, 0);\">题目二 实现BFS&nbsp;</span></span><span style=\"background-color: rgb(254, 250, 0);\"><span style=\"font-size: 14px; line-height: 19px;\">—</span><span style=\"font-size: 14px;\">&nbsp;red black tree</span></span></font></li><li style=\"font-size: 14px;\"><font color=\"#444444\">第三题，关于suffix和prefix的题，给一个list，存一些词，然后组合成新词，然后把新词加到list，问longest word。比如 danc nce 可以组合成dance，然后dance存在list里面，dance又可以跟其他词组成新词。问这题的时候没时间了，让我讲讲思路。然后写pseudo code。这个题我花了点时间，但是也写了大概。这题我是后来面完跟我老板讨论，发现有漏洞，就是前缀和后缀一样，可以一直不停地组合，所以可能要判断一下。</font></li><li style=\"font-size: 14px;\"><span style=\"color: rgb(85, 85, 85); font-family: Tahoma, 'Microsoft Yahei', STXihei, Simsun; line-height: 19.0909px; widows: 1; background-color: rgb(255, 255, 255);\">Problem 2：给两个长度N的数组，A</span><i style=\"word-wrap: break-word; color: rgb(85, 85, 85); font-family: Tahoma, 'Microsoft Yahei', STXihei, Simsun; line-height: 19.0909px; widows: 1; background-color: rgb(255, 255, 255);\">, B<i style=\"word-wrap: break-word;\">，它们都是sorted的，找出矩阵 M[i]<i style=\"word-wrap: break-word;\">[j] = A[i]<i style=\"word-wrap: break-word;\">&nbsp;+ B[j]中，N个最大的数，输出它们。 — 从最后一个开始找 有点像merge sort</i></i></i></i></li><li style=\"font-size: 14px;\">第二题是求一个矩阵内的最大子矩阵和，然后问了如果矩阵里有负数有没有关系 — 先求和 转化求差值</li><li style=\"font-size: 14px;\"><font class=\"jammer\">第一个是running average， 有个capacity<br>第二个是大数相加。敲完之后赶紧发现没考虑负数，问要不要补上，他说不用了，知道就好。<br></font></li><li style=\"font-size: 14px;\"><font class=\"jammer\">问binary tree中怎么找到最接近输入x的node； &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>第一题问给一个int x, 怎么找到最接近x的整数平方根y (eg x=49 y=7 or x=50 y=7)<font class=\"jammer\">.&nbsp;</font><br>第二题问给一个int x, 找到某个平方根组合相加可以组成x (eg x=51=1^2+1^2+7^2, 答案为1, 1, 7)<font class=\"jammer\">. 鐗 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></font>第三轮：问给一个iterator的list, 怎么设计一个overall的iterator会轮流iterate各个iterator的element</li><li><span style=\"font-size: 14px;\">&nbsp;国人大哥，态度很好 。题目是求一个数的立方根（二分），分析复杂度，follow up，假如要求精确到小数后k位 </span><span style=\"background-color: rgb(254, 250, 0);\"><span style=\"font-size: 14px;\">newton method 不再选取两个的平均值&nbsp;</span><span style=\"font-size: 14px; line-height: 19px;\">—</span><span style=\"font-size: 14px;\">&nbsp;而是 x(n + 1) = (xn + S/xn) / 2</span></span><br></li><li style=\"font-size: 14px;\"><a href=\"http://www.1point3acres.com/bbs/forum.php?mod=viewthread&amp;tid=127743&amp;extra=page%3D1%26filter%3Dsortid%26sortid%3D311%26searchoption%5B3090%5D%5Bvalue%5D%3D2%26searchoption%5B3090%5D%5Btype%5D%3Dradio%26searchoption%5B3046%5D%5Bvalue%5D%3D1%26searchoption%5B3046%5D%5Btype%5D%3Dradio%26sortid%3D311\" style=\"background-color: rgb(254, 250, 0);\">http://www.1point3acres.com/bbs/forum.php?mod=viewthread&amp;tid=127743&amp;extra=page%3D1%26filter%3Dsortid%26sortid%3D311%26searchoption%5B3090%5D%5Bvalue%5D%3D2%26searchoption%5B3090%5D%5Btype%5D%3Dradio%26searchoption%5B3046%5D%5Bvalue%5D%3D1%26searchoption%5B3046%5D%5Btype%5D%3Dradio%26sortid%3D311</a><br></li><li style=\"font-size: 14px;\">美国人。给一个input，是一句话有一些words，空格隔开。指定屏幕的行和列，问把这句话重复打印到屏幕上最多能打印多少遍。先写了个暴力的，一个一个词放进去看能打印多少遍。follow up，如果行和列非常大，这样解效率太低，有什么更好的方法。想了一会，可以弄个look up table。 key是每一个单词的index。value记录下以key为每行的第一个单词时，最后一个单词的index和这句话在这一行能打印多少遍。然后一行行找就行了，复杂度就是行的个数。 &nbsp; &nbsp;&nbsp;美国人。 第一题， 给两个int的list，检查两个list是不是permutations.我用的hashmap做的。<font class=\"jammer\"></font><br>第二题，给一个二维数组。返回一个数组，数组元素(i,j)是提供数组的（0，0) 到（i,j)矩形里的所有元素的和。<br></li><li style=\"font-size: 14px;\"><a href=\"http://www.1point3acres.com/bbs/forum.php?mod=viewthread&amp;tid=125601&amp;extra=page%3D1%26filter%3Dsortid%26sortid%3D311%26searchoption%5B3090%5D%5Bvalue%5D%3D2%26searchoption%5B3090%5D%5Btype%5D%3Dradio%26searchoption%5B3046%5D%5Bvalue%5D%3D1%26searchoption%5B3046%5D%5Btype%5D%3Dradio%26sortid%3D311\">http://www.1point3acres.com/bbs/forum.php?mod=viewthread&amp;tid=125601&amp;extra=page%3D1%26filter%3Dsortid%26sortid%3D311%26searchoption%5B3090%5D%5Bvalue%5D%3D2%26searchoption%5B3090%5D%5Btype%5D%3Dradio%26searchoption%5B3046%5D%5Bvalue%5D%3D1%26searchoption%5B3046%5D%5Btype%5D%3Dradio%26sortid%3D311</a>&nbsp;done</li><li style=\"font-size: 14px;\">1, 0到99，求missing number刚开始答了二分去找，像merge sort一样， 三哥不满意 最坏还是O(n)。最后答了一次从头扫到尾，三哥还算满意。</li><li style=\"font-size: 14px;\">2, 国人. 感觉最好的一轮(1)hashcode equals干啥的。自己写一个String的hashCode方法<span style=\"background-color: rgb(254, 250, 0);\">.</span><span style=\"line-height: 1.4;\"><span style=\"background-color: rgb(254, 250, 0);\">(2)static方法上加synchronize和非static方法上加synchronize有啥区别 有static锁class 没有的话锁object</span>(3)给一个list of Iterator &nbsp; 给一个isPrim(int a)方法 &nbsp;都是已知的。 写一个class implement Iterator, &nbsp;跟据listOfIterator 迭代出prim3, 老美挂在这轮了,前两轮面完有点累,面一半手机还出问题了耽误了好久,最后用hangout面完了。给个二叉树的Node，返回最深结点。面完后想了想，当时直接写个bfs的类似level order travel的解法好了。。。</span></li><li style=\"font-size: 14px;\">国人大哥，很nice，就上了merge sorted list和另一个也超简单的二叉树的题。 第二轮， 白人，听语气感觉上年纪了。整个过程对方爱答不理，也就做了一个题。问题是想要shuffle一个string，使得最终没有相同的character相邻。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 第三轮<span style=\"line-height: 1.4;\">&nbsp;听不出那里口音，最可能是印度小哥。也只问了一个问题。就是求子矩阵的sum，其中子矩阵左上角一定是从(0, 0)开始。问题很弱，就是最简单的DP吧。</span></li><li style=\"font-size: 14px;\"><a href=\"http://www.1point3acres.com/bbs/forum.php?mod=viewthread&amp;tid=114171&amp;extra=page%3D1%26filter%3Dsortid%26sortid%3D311%26searchoption%5B3090%5D%5Bvalue%5D%3D2%26searchoption%5B3090%5D%5Btype%5D%3Dradio%26searchoption%5B3046%5D%5Bvalue%5D%3D1%26searchoption%5B3046%5D%5Btype%5D%3Dradio%26sortid%3D311\">http://www.1point3acres.com/bbs/forum.php?mod=viewthread&amp;tid=114171&amp;extra=page%3D1%26filter%3Dsortid%26sortid%3D311%26searchoption%5B3090%5D%5Bvalue%5D%3D2%26searchoption%5B3090%5D%5Btype%5D%3Dradio%26searchoption%5B3046%5D%5Bvalue%5D%3D1%26searchoption%5B3046%5D%5Btype%5D%3Dradio%26sortid%3D311</a>&nbsp;done<br></li><li style=\"font-size: 14px;\"><span style=\"color: rgb(85, 85, 85); font-family: Tahoma, 'Microsoft Yahei', STXihei, Simsun; line-height: 19.0909px; widows: 1; background-color: rgb(255, 255, 255);\">車牌 RO 1287 [\"rolling\", \"real\", \"WhaT\", \"rOad\"] =&gt; \"rOad\"</span><font class=\"jammer\" style=\"word-wrap: break-word; font-size: 10px; color: rgb(255, 255, 255); font-family: Tahoma, 'Microsoft Yahei', STXihei, Simsun; widows: 1; background-color: rgb(255, 255, 255);\"></font><br style=\"word-wrap: break-word; color: rgb(85, 85, 85); font-family: Tahoma, 'Microsoft Yahei', STXihei, Simsun; line-height: 19.0909px; widows: 1; background-color: rgb(255, 255, 255);\"><span style=\"color: rgb(85, 85, 85); font-family: Tahoma, 'Microsoft Yahei', STXihei, Simsun; line-height: 19.0909px; widows: 1; background-color: rgb(255, 255, 255);\">follow up:</span><font class=\"jammer\" style=\"word-wrap: break-word; font-size: 10px; color: rgb(255, 255, 255); font-family: Tahoma, 'Microsoft Yahei', STXihei, Simsun; widows: 1; background-color: rgb(255, 255, 255);\"></font><br style=\"word-wrap: break-word; color: rgb(85, 85, 85); font-family: Tahoma, 'Microsoft Yahei', STXihei, Simsun; line-height: 19.0909px; widows: 1; background-color: rgb(255, 255, 255);\"><span style=\"color: rgb(85, 85, 85); font-family: Tahoma, 'Microsoft Yahei', STXihei, Simsun; line-height: 19.0909px; widows: 1; background-color: rgb(255, 255, 255);\">(1) 如果dictionary裡有上百萬個字，該如何加速</span><font class=\"jammer\" style=\"word-wrap: break-word; font-size: 10px; color: rgb(255, 255, 255); font-family: Tahoma, 'Microsoft Yahei', STXihei, Simsun; widows: 1; background-color: rgb(255, 255, 255);\"></font><br style=\"word-wrap: break-word; color: rgb(85, 85, 85); font-family: Tahoma, 'Microsoft Yahei', STXihei, Simsun; line-height: 19.0909px; widows: 1; background-color: rgb(255, 255, 255);\"><span style=\"color: rgb(85, 85, 85); font-family: Tahoma, 'Microsoft Yahei', STXihei, Simsun; line-height: 19.0909px; widows: 1; background-color: rgb(255, 255, 255);\">(2) 如果dictionary有上百萬個字，然後給你上千個車牌號碼，要你回傳相對應的最短字串，該如何optimize</span><br></li><li style=\"font-size: 14px;\"><span style=\"color: rgb(85, 85, 85); font-family: Tahoma, 'Microsoft Yahei', STXihei, Simsun; line-height: 19.0909px; widows: 1; background-color: rgb(255, 255, 255);\">for 23: 用质数存每一个字母 然后如果能整除就包括所有的数字</span></li><li style=\"font-size: 14px;\"><a href=\"http://www.1point3acres.com/bbs/forum.php?mod=viewthread&amp;tid=113812&amp;extra=page%3D1%26filter%3Dsortid%26sortid%3D311%26searchoption%5B3090%5D%5Bvalue%5D%3D2%26searchoption%5B3090%5D%5Btype%5D%3Dradio%26searchoption%5B3046%5D%5Bvalue%5D%3D1%26searchoption%5B3046%5D%5Btype%5D%3Dradio%26sortid%3D311\">http://www.1point3acres.com/bbs/forum.php?mod=viewthread&amp;tid=113812&amp;extra=page%3D1%26filter%3Dsortid%26sortid%3D311%26searchoption%5B3090%5D%5Bvalue%5D%3D2%26searchoption%5B3090%5D%5Btype%5D%3Dradio%26searchoption%5B3046%5D%5Bvalue%5D%3D1%26searchoption%5B3046%5D%5Btype%5D%3Dradio%26sortid%3D311</a>&nbsp;done</li><li style=\"font-size: 14px;\">Given 2D matrix, N*N, element ranging from 1 - N^2, no duplicate.<font class=\"jammer\"></font><br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;return the length of longest consective path&nbsp;<font class=\"jammer\"></font><br><br>Eg.&nbsp;&nbsp;1 3 5<font class=\"jammer\"></font><br>&nbsp; &nbsp;&nbsp; &nbsp; 2 4 6<font class=\"jammer\"></font><br>&nbsp; &nbsp;&nbsp; &nbsp; 9 8 7<br>&nbsp; &nbsp; &nbsp; Should return 5 because path 5 6 7 8 9 has the longest path length</li></ol></div></div>"
    }
  ]
}